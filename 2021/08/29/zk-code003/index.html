<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="lanicc">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      ZooKeeper源码阅读——ZooKeeperServer | lanicc
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>lanicc</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>ZooKeeper源码阅读——ZooKeeperServer</h2>
  <p class="post-date">2021-08-29</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p><code>ZookeeperServer</code>是一个简单的单机的实现。请求处理链为：<br><code>PrepRequestProcessor -&gt; SyncRequestProcessor -&gt; FinalRequestProcessor</code></p>
<span id="more"></span>

<p>看一下<code>ZooKeeperServer</code>的启动流程，<code>ZooKeeperServer</code>的启动是在<code>ServerCnxnFactory</code>中进行的<br>在<code>NIOServerCnxnFactory.startup</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">(ZooKeeperServer zks, <span class="keyword">boolean</span> startServer)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    setZooKeeperServer(zks);</span><br><span class="line">    <span class="keyword">if</span> (startServer) &#123;</span><br><span class="line">        zks.startdata();</span><br><span class="line">        zks.startup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>startdata</code>是恢复本地数据，每次在zookeeper启动的时候都需要从本地快照数据文件和事务文件中进行数据恢复</li>
<li><code>startup</code>启动zkServer</li>
</ul>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Restore sessions and data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When a new leader starts executing Leader#lead, it</span></span><br><span class="line"><span class="comment">     * invokes this method. The database, however, has been</span></span><br><span class="line"><span class="comment">     * initialized before running leader election so that</span></span><br><span class="line"><span class="comment">     * the server could pick its zxid for its initial vote.</span></span><br><span class="line"><span class="comment">     * It does it by invoking QuorumPeer#getLastLoggedZxid.</span></span><br><span class="line"><span class="comment">     * Consequently, we don&#x27;t need to initialize it once more</span></span><br><span class="line"><span class="comment">     * and avoid the penalty of loading it a second time. Not</span></span><br><span class="line"><span class="comment">     * reloading it is particularly important for applications</span></span><br><span class="line"><span class="comment">     * that host a large database.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The following if block checks whether the database has</span></span><br><span class="line"><span class="comment">     * been initialized or not. Note that this method is</span></span><br><span class="line"><span class="comment">     * invoked by at least one other method:</span></span><br><span class="line"><span class="comment">     * ZooKeeperServer#startdata.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See ZOOKEEPER-1642 for more detail.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (zkDb.isInitialized()) &#123;</span><br><span class="line">        setZxid(zkDb.getDataTreeLastProcessedZxid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setZxid(zkDb.loadDataBase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up dead sessions</span></span><br><span class="line">    zkDb.getSessions().stream()</span><br><span class="line">                    .filter(session -&gt; zkDb.getSessionWithTimeOuts().get(session) == <span class="keyword">null</span>)</span><br><span class="line">                    .forEach(session -&gt; killSession(session, zkDb.getDataTreeLastProcessedZxid()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a clean snapshot</span></span><br><span class="line">    takeSnapshot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面对的代码中可以看到，主要分为<code>loadData</code>三步：</p>
<ul>
<li>加载数据库，设置zxid</li>
<li>清理过期session</li>
<li>生成一个快照</li>
</ul>
<p>逐步研究</p>
<h3 id="加载数据库"><a href="#加载数据库" class="headerlink" title="加载数据库"></a>加载数据库</h3><p>时序如下<br><img src="/images/zk/ZKDatabase_loadDataBase.png" alt="ZKDatabase.loadDataBase"></p>
<p>可以看到，<code>ZKDataBase.loadDataBase</code>是通过<code>FileTxnSnapLog</code>提供的能力实现的，前面也说过，<code>FileTxnSnapLog</code>是zk中的数据管理器，是用来操作事务日志和快照的工具类。</p>
<h4 id="1-1-1-deserialize-快照恢复"><a href="#1-1-1-deserialize-快照恢复" class="headerlink" title="1.1.1 deserialize 快照恢复"></a>1.1.1 deserialize 快照恢复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">deserialize</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// we run through 100 snapshots (not all of them)</span></span><br><span class="line">    <span class="comment">// if we cannot get it running within 100 snapshots</span></span><br><span class="line">    <span class="comment">// we should  give up</span></span><br><span class="line">    List&lt;File&gt; snapList = findNValidSnapshots(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (snapList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File snap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> snapZxid = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> foundValid = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, snapListSize = snapList.size(); i &lt; snapListSize; i++) &#123;</span><br><span class="line">        snap = snapList.get(i);</span><br><span class="line">        LOG.info(<span class="string">&quot;Reading snapshot &#123;&#125;&quot;</span>, snap);</span><br><span class="line">        snapZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);</span><br><span class="line">        <span class="keyword">try</span> (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) &#123;</span><br><span class="line">            InputArchive ia = BinaryInputArchive.getArchive(snapIS);</span><br><span class="line">            deserialize(dt, sessions, ia);</span><br><span class="line">            SnapStream.checkSealIntegrity(snapIS, ia);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Digest feature was added after the CRC to make it backward</span></span><br><span class="line">            <span class="comment">// compatible, the older code can still read snapshots which</span></span><br><span class="line">            <span class="comment">// includes digest.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// To check the intact, after adding digest we added another</span></span><br><span class="line">            <span class="comment">// CRC check.</span></span><br><span class="line">            <span class="keyword">if</span> (dt.deserializeZxidDigest(ia, snapZxid)) &#123;</span><br><span class="line">                SnapStream.checkSealIntegrity(snapIS, ia);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foundValid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;problem reading snap file &#123;&#125;&quot;</span>, snap, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!foundValid) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Not able to find valid snapshots in &quot;</span> + snapDir);</span><br><span class="line">    &#125;</span><br><span class="line">    dt.lastProcessedZxid = snapZxid;</span><br><span class="line">    lastSnapshotInfo = <span class="keyword">new</span> SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare the digest if this is not a fuzzy snapshot, we want to compare</span></span><br><span class="line">    <span class="comment">// and find inconsistent asap.</span></span><br><span class="line">    <span class="keyword">if</span> (dt.getDigestFromLoadedSnapshot() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dt.compareSnapshotDigests(dt.lastProcessedZxid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dt.lastProcessedZxid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第5行，<code>findNValidSnapshots</code>是用来查找100个合法的且最近的快照文件</li>
<li>第15行，根据快照名称解析出zxid</li>
<li>第18行，反序列化快照，将反序列化处的session数据和节点数据分别填充到sessions和dt中</li>
<li>第31行，虽然查询的是最近的100个快照文件，但是可以看到当找到一个最新的合法的快照后，就不会再继续往下了，也就是说只有在最新的快照不可用时，才会使用历史快照恢复</li>
<li>第40、41行，记录最后的zxid</li>
</ul>
<p>经过上面的快照恢复，zk中已经存在一份近乎全量的数据了，下面就要通过快照对数据进行增量恢复</p>
<h4 id="1-1-3-1-fastForwardFromEdits-事务日志恢复"><a href="#1-1-3-1-fastForwardFromEdits-事务日志恢复" class="headerlink" title="1.1.3.1 fastForwardFromEdits 事务日志恢复"></a>1.1.3.1 fastForwardFromEdits 事务日志恢复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fastForwardFromEdits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DataTree dt,</span></span></span><br><span class="line"><span class="params"><span class="function">    Map&lt;Long, Integer&gt; sessions,</span></span></span><br><span class="line"><span class="params"><span class="function">    PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> highestZxid = dt.lastProcessedZxid;</span><br><span class="line">    TxnHeader hdr;</span><br><span class="line">    <span class="keyword">int</span> txnLoaded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> startTime = Time.currentElapsedTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// iterator points to</span></span><br><span class="line">            <span class="comment">// the first valid txn when initialized</span></span><br><span class="line">            hdr = itr.getHeader();</span><br><span class="line">            <span class="keyword">if</span> (hdr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//empty logs</span></span><br><span class="line">                <span class="keyword">return</span> dt.lastProcessedZxid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != <span class="number">0</span>) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;&#123;&#125;(highestZxid) &gt; &#123;&#125;(next log) for type &#123;&#125;&quot;</span>, highestZxid, hdr.getZxid(), hdr.getType());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                highestZxid = hdr.getZxid();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processTransaction(hdr, dt, sessions, itr.getTxn());</span><br><span class="line">                dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());</span><br><span class="line">                txnLoaded++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Failed to process transaction type: &quot;</span></span><br><span class="line">                                      + hdr.getType()</span><br><span class="line">                                      + <span class="string">&quot; error: &quot;</span></span><br><span class="line">                                      + e.getMessage(),</span><br><span class="line">                                      e);</span><br><span class="line">            &#125;</span><br><span class="line">            listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());</span><br><span class="line">            <span class="keyword">if</span> (!itr.next()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (itr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            itr.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> loadTime = Time.currentElapsedTime() - startTime;</span><br><span class="line">    LOG.info(<span class="string">&quot;&#123;&#125; txns loaded in &#123;&#125; ms&quot;</span>, txnLoaded, loadTime);</span><br><span class="line">    ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);</span><br><span class="line">    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> highestZxid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第5行，从快照恢复的zxid+1，开始读取事务日志</li>
<li>第25行，根据事务日志恢复数据</li>
</ul>
<p>数据恢复到此结束，下一步启动zkServer</p>
<h2 id="启动zkServer"><a href="#启动zkServer" class="headerlink" title="启动zkServer"></a>启动zkServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startupWithServerState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    &#125;</span><br><span class="line">    startSessionTracker();</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    startRequestThrottler();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    startJvmPauseMonitor();</span><br><span class="line"></span><br><span class="line">    registerMetrics();</span><br><span class="line"></span><br><span class="line">    setState(state);</span><br><span class="line"></span><br><span class="line">    requestPathMetricsCollector.start();</span><br><span class="line"></span><br><span class="line">    localSessionEnabled = sessionTracker.isLocalSessionsEnabled();</span><br><span class="line"></span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第3行，创建<code>sessionTracker</code></li>
<li>第5行，启动<code>sessionTracker</code></li>
<li>第6行，设置请求处理器<code>RequestProcessor</code></li>
<li>第8行，启动请求节流器<code>RequestThrottler</code></li>
<li>第16行，设置状态</li>
</ul>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>在前面的<code>NIOServerCnxn</code>的<code>doIO</code>调用链中，可以看到实际上请求是交给zkServer处理的</p>
<h3 id="连接请求处理"><a href="#连接请求处理" class="headerlink" title="连接请求处理"></a>连接请求处理</h3><p><code>ZooKeeperServer.processConnectRequest</code>方法处理连接请求</p>
<ul>
<li>对于新连接请求: 会创建session，并将封装请求为<code>Request</code>对象，交给<code>RequestThrottler</code>处理</li>
<li>对于重连的请求: 会对session进行校验，通过后重新打开session</li>
</ul>
<h3 id="其他请求处理"><a href="#其他请求处理" class="headerlink" title="其他请求处理"></a>其他请求处理</h3><p><code>ZooKeeperServer.processPacket</code>方法处理连接请求</p>
<h3 id="RequestThrottler-请求限流器"><a href="#RequestThrottler-请求限流器" class="headerlink" title="RequestThrottler 请求限流器"></a>RequestThrottler 请求限流器</h3><p><code>RequestThrottler</code>会限制当前提交到请求处理器管道的未完成的请求数量。<br><code>RequestThrottler</code>是如何实现限流功能的呢？</p>
<ul>
<li><code>RequestThrottler</code>内部会维护一个队列<code>submittedRequests</code>，当<code>zkServer</code>调用<code>RequestThrottler.submitRequest()</code>时，<code>RequestThrottler</code>会现将请求放到队列<code>submittedRequests</code>中。</li>
<li><code>RequestThrottler</code>又是<code>ZooKeeperCriticalThread</code>的子类，所以在调用其<code>start</code>方法时，实际上是启动了一个线程，这个线程会执行<code>RequestThrottler.run()</code>方法，在<code>run</code>方法中，<code>RequestThrottler</code>通过不断的比较<code>zkServer</code>正在处理的请求数量和最大允许的请求数量，判断是等待还是立即提交给<code>zkServer</code>处理。</li>
</ul>
<p>通过<code>submittedRequests</code>加一个受控的消费队列的线程，就实现了限流器的功能</p>
<p>看一下细节</p>
<h4 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h4><ul>
<li><code>zookeeper.request_throttle_max_requests</code>-<code>maxRequests</code>:<br>The total number of outstanding requests allowed before the RequestThrottler starts stalling. When set to 0, throttling is disabled. The default is 0.允许在<code>zkServer</code>中未完成的请求数量(即不做限流的请求数)，如果设置为0，即不开启限流功能，默认为0</li>
<li><code>zookeeper.request_throttle_stall_time</code>-<code>stallTime</code>:<br>The maximum time (in milliseconds) for which a thread may wait to be notified that it may proceed processing a request. The default is 100.请求等待线程处理的最大时间，其实就是在一个循环中线程的休眠时间，等会看代码就知道了。</li>
<li><code>request_throttle_drop_stale</code>-<code>dropStaleRequests</code>:<br>When enabled, the throttler will drop stale requests rather than issue them to the request pipeline. A stale request is a request sent by a connection that is now closed, and/or a request that will have a request latency higher than the sessionTimeout. The default is true.如果开启这个配置，限流器将会直接丢弃超时的请求，而不是交给请求处理器处理。默认是开启。</li>
<li><code>zookeeper.throttled_op_wait_time</code>-<code>throttledOpWaitTime</code>: 这个配置是一个<code>ZooKeeperServer</code>的配置，后面说</li>
</ul>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>看一下<code>run</code>方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Request request = submittedRequests.take();</span><br><span class="line">            <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (request.mustDrop()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Throttling is disabled when maxRequests = 0</span></span><br><span class="line">            <span class="keyword">if</span> (maxRequests &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!killed) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dropStaleRequests &amp;&amp; request.isStale()) &#123;</span><br><span class="line">                        <span class="comment">// Note: this will close the connection</span></span><br><span class="line">                        dropRequest(request);</span><br><span class="line">                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(<span class="number">1</span>);</span><br><span class="line">                        request = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (zks.getInProcess() &lt; maxRequests) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    throttleSleep(stallTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// A dropped stale request will be null</span></span><br><span class="line">            <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isStale()) &#123;</span><br><span class="line">                    ServerMetrics.getMetrics().STALE_REQUESTS.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> elapsedTime = Time.currentElapsedTime() - request.requestThrottleQueueTime;</span><br><span class="line">                ServerMetrics.getMetrics().REQUEST_THROTTLE_QUEUE_TIME.add(elapsedTime);</span><br><span class="line">                <span class="keyword">if</span> (shouldThrottleOp(request, elapsedTime)) &#123;</span><br><span class="line">                  request.setIsThrottled(<span class="keyword">true</span>);</span><br><span class="line">                  ServerMetrics.getMetrics().THROTTLED_OPS.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                zks.submitRequestNow(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unexpected interruption&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dropped = drainQueue();</span><br><span class="line">    LOG.info(<span class="string">&quot;RequestThrottler shutdown. Dropped &#123;&#125; requests&quot;</span>, dropped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第9行，从队列中取出一个请求，队列先进先出，所以是按照请求的到达顺序处理的</li>
<li>第19行，通过配置<code>maxRequests</code>的值，判断是否开启了限流功能，如果开启了，会进入下面的<code>while</code>循环</li>
<li>第21行，通过配置<code>dropStaleRequests</code>判断是否开启了超时自动自动丢弃，通过<code>request.isStale()</code>判断该请求是否已经超时，如果满足这两个条件，就会将超时的请求直接处理掉</li>
<li>第46行，判断请求在<code>RequestThrottler</code>中的耗时，是否超过了请求标记的限流耗时，如果超过了的话，<code>FinalProcessor</code>处理器就会返回一个错误相应(错误码<code>ZTHROTTLEDOP</code>)，并且会将该请求标记为限流超时，即<code>setIsThrottled</code>为<code>true</code></li>
<li>第50行，将请求提交给<code>zkServer</code>处理，<code>zkServer.submitRequestNow()</code>中，会更新请求的<code>session</code>过期时间，校验请求类型，然后将请求提交给请求处理链的第一个请求处理器处理。</li>
</ul>
<h3 id="RequestProcessor-请求处理器"><a href="#RequestProcessor-请求处理器" class="headerlink" title="RequestProcessor 请求处理器"></a>RequestProcessor 请求处理器</h3><p>zkServer的请求处理器是在<code>setupRequestProcessors</code>中初始化并启动的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>, finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor) syncProcessor).start();</span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor) firstProcessor).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器链:<br><code>(PrepRequestProcessor) firstProcessor</code><br>    =&gt; <code>(SyncRequestProcessor) syncProcessor</code><br>        =&gt; <code>(FinalRequestProcessor) finalProcessor</code></p>
<p>处理器链类似于<code>javax.servlet.Filter</code>的设计，也是一种链式调动，这种设计模式，叫做责任链</p>
<p>看一下上面三种处理器的继承关系<br><img src="/images/zk/RequetProcessor_Impl.png" alt="RequestProcessor继承关系"></p>
<p>可以看到<code>PrepRequestProcessor</code>和<code>SyncRequestProcessor</code>都是<code>Thread</code><br>的子类，因为当调用它们的<code>start</code>方法时，都会启动一个线程</p>
<p>再看一下<code>RequestProcessor</code>接口</p>
<blockquote><p>RequestProcessors are chained together to process transactions. Requests are always processed in order. The standalone server, follower, and leader all have slightly different RequestProcessors chained together. Requests always move forward through the chain of RequestProcessors. Requests are passed to a RequestProcessor through processRequest(). Generally method will always be invoked by a single thread. When shutdown is called, the request RequestProcessor should also shutdown any RequestProcessors that it is connected to.</p>
</blockquote>

<p>意思就是说，多个请求处理器以链式处理事务。按顺序处理。单机、follower、leader都有不同的请求处理器链。请求通过<code>RequestProcessor</code>的<code>processRequest()</code>方法在处理器链中传递。通常，这个方法都是被单线程调用。当调用<code>shutdown</code>时，链中的其他<code>RequestProcessor</code>也应当<code>shutdown</code>。</p>
<p>该接口只定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>与文档中描述的一致<br><code>processRequest</code>的入参就是<code>Request</code>，用来接收需要处理的请求</p>
<h4 id="PrepRequestProcessor"><a href="#PrepRequestProcessor" class="headerlink" title="PrepRequestProcessor"></a>PrepRequestProcessor</h4><ul>
<li><p>从前面可以知道<code>PrepRequestProcessor</code>实际上是<code>Thread</code>的子类<br>所以当调用其<code>start</code>方法时，会启动一个线程</p>
</li>
<li><p>查看<code>PrepRequestProcessor</code>的<code>processRequest</code>方法的代码，可以看到，该方法内并没有直接处理，而是先将请求存放到队列<code>submittedRequests</code>中</p>
</li>
<li><p><code>PrepRequestProcessor</code>的<code>run</code>方法会从队列<code>submittedRequests</code>中取出待处理的请求进行处理</p>
</li>
</ul>
<p>看下<code>run</code>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG.info(String.format(<span class="string">&quot;PrepRequestProcessor (sid:%d) started, reconfigEnabled=%s&quot;</span>, zks.getServerId(), zks.reconfigEnabled));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());</span><br><span class="line">            Request request = submittedRequests.take();</span><br><span class="line">            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME</span><br><span class="line">                .add(Time.currentElapsedTime() - request.prepQueueStartTime);</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</span><br><span class="line">                <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</span><br><span class="line">                    traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</span><br><span class="line">                &#125;</span><br><span class="line">                ZooTrace.logRequest(LOG, traceMask, <span class="string">&#x27;P&#x27;</span>, request, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.prepStartTime = Time.currentElapsedTime();</span><br><span class="line">            pRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        handleException(<span class="keyword">this</span>.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;PrepRequestProcessor exited loop!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第7行，从<code>submittedRequests</code>队列中取出请求</li>
<li>第22行，调用<code>pRequest</code>处理</li>
</ul>
<p><code>pRequest</code>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>&#123;</span><br><span class="line">    <span class="comment">// LOG.info(&quot;Prep&gt;&gt;&gt; cxid = &quot; + request.cxid + &quot; type = &quot; +</span></span><br><span class="line">    <span class="comment">// request.type + &quot; id = 0x&quot; + Long.toHexString(request.sessionId));</span></span><br><span class="line">    request.setHdr(<span class="keyword">null</span>);</span><br><span class="line">    request.setTxn(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!request.isThrottled()) &#123;</span><br><span class="line">      pRequestHelper(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.zxid = zks.getZxid();</span><br><span class="line">    <span class="keyword">long</span> timeFinishedPrepare = Time.currentElapsedTime();</span><br><span class="line">    ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(timeFinishedPrepare - request.prepStartTime);</span><br><span class="line">    nextProcessor.processRequest(request);</span><br><span class="line">    ServerMetrics.getMetrics().PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - timeFinishedPrepare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第7行，如果请求没有被标记为限流超时，会调用<code>pRequestHelper</code>处理，对于事务请求，在<code>pRequestHelper</code>方法中，<code>PrepRequestProcessor</code>会为事务请求创建事务头、事务体，对于非事务请求，<code>PrepRequestProcessor</code>会进行<code>checkSession</code>操作</li>
<li>第14行，交给下一个处理器处理</li>
</ul>
<h4 id="SyncRequestProcessor"><a href="#SyncRequestProcessor" class="headerlink" title="SyncRequestProcessor"></a>SyncRequestProcessor</h4><p>看一下javadoc</p>
<blockquote>
<p>This RequestProcessor logs requests to disk. It batches the requests to do the io efficiently. The request is not passed to the next RequestProcessor until its log has been synced to disk. SyncRequestProcessor is used in 3 different cases 1. Leader - Sync request to disk and forward it to AckRequestProcessor which send ack back to itself. 2. Follower - Sync request to disk and forward request to SendAckRequestProcessor which send the packets to leader. SendAckRequestProcessor is flushable which allow us to force push packets to leader. 3. Observer - Sync committed request to disk (received as INFORM packet). It never send ack back to the leader, so the nextProcessor will be null. This change the semantic of txnlog on the observer since it only contains committed txns.</p>
</blockquote>
<p>意思就说，这个<code>SyncRequestProcessor</code>请求处理器会将请求记录到磁盘。会进行批量处理以便高效地执行IO操作。在将日志同步到磁盘之前，不会将请求交给下一个处理器。<br><code>SyncRequestProcessor</code>有3个不通的使用场景：</p>
<ol>
<li>Leader - 将请求同步到磁盘并转发给<code>AckRequestProcessor</code>，后者将ack发送给自身</li>
<li>Follower - 将请求同步到磁盘，并将请求转发给<code>SendAckRequestProcessor</code>，后者将数据包发送给leader。</li>
<li>Observer - 将提交的请求同步到磁盘</li>
</ol>
<p>从上面的文档介绍中可以知晓<code>SyncRequestProcessor</code>的主要作用是将请求同步到磁盘，对请求进行持久化，然后再转发给下一个处理器处理。</p>
<p><code>SyncRequestProcessor</code>内部维护了两个队列:</p>
<ul>
<li><code>queuedRequests</code>: 新的请求提交到<code>SyncRequestProcessor</code>时，不会直接处理，而是先进入<code>queuedRequests</code>队列，等待处理。当调用<code>SyncRequestProcessor.shutdown()</code>方法时，也不会立即就停掉，而是往<code>queuedRequests</code>队列中添加一个特殊的请求<code>REQUEST_OF_DEATH</code>，当<code>SyncRequestProcessor</code>从队列<code>queuedRequests</code>消费到<code>REQUEST_OF_DEATH</code>请求后，就会退出</li>
<li><code>toFlush</code>: <code>SyncRequestProcessor</code>将从队列<code>queuedRequests</code>中获取到请求后，会先记录事务日志，然后将请求添加到<code>toFlush</code>队列，后续经过一些条件判断后，再将<code>toFlush</code>队列中的请求提交给下一个请求处理器</li>
</ul>
<p>还有一点需要注意，javadoc中所说的持久化到磁盘，其实包含两类操作：</p>
<ul>
<li>记录事务日志: 从<code>queuedRequests</code>中消费的每个请求(事务请求)都会先记录事务日志，然后进入到<code>toFlush</code>队列</li>
<li>快照: 事务日志记录完成后，会判断是否需要进行快照操作，如果需要进行快照，会单独启动一个线程进行快照操作</li>
</ul>
<p>看一下源码实现</p>
<p><code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></span><br><span class="line">        <span class="comment">// in the ensemble take a snapshot at the same time</span></span><br><span class="line">        resetSnapshotStats();</span><br><span class="line">        lastFlushTime = Time.currentElapsedTime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());</span><br><span class="line">            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* We timed out looking for more writes to batch, go ahead and flush immediately */</span></span><br><span class="line">                flush();</span><br><span class="line">                si = queuedRequests.take();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (si == REQUEST_OF_DEATH) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> startProcessTime = Time.currentElapsedTime();</span><br><span class="line">            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// track the number of records written to the log</span></span><br><span class="line">            <span class="keyword">if</span> (!si.isThrottled() &amp;&amp; zks.getZKDatabase().append(si)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldSnapshot()) &#123;</span><br><span class="line">                    resetSnapshotStats();</span><br><span class="line">                    <span class="comment">// roll the log</span></span><br><span class="line">                    zks.getZKDatabase().rollLog();</span><br><span class="line">                    <span class="comment">// take a snapshot</span></span><br><span class="line">                    <span class="keyword">if</span> (!snapThreadMutex.tryAcquire()) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Too busy to snap, skipping&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">new</span> ZooKeeperThread(<span class="string">&quot;Snapshot Thread&quot;</span>) &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    zks.takeSnapshot();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    snapThreadMutex.release();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;.start();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// optimization for read heavy workloads</span></span><br><span class="line">                <span class="comment">// iff this is a read or a throttled request(which doesn&#x27;t need to be written to the disk),</span></span><br><span class="line">                <span class="comment">// and there are no pending flushes (writes), then just pass this to the next processor</span></span><br><span class="line">                <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nextProcessor.processRequest(si);</span><br><span class="line">                    <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</span><br><span class="line">                        ((Flushable) nextProcessor).flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            toFlush.add(si);</span><br><span class="line">            <span class="keyword">if</span> (shouldFlush()) &#123;</span><br><span class="line">                flush();</span><br><span class="line">            &#125;</span><br><span class="line">            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleException(<span class="keyword">this</span>.getName(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;SyncRequestProcessor exited!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第6行，从代码注释上可以看到，但是还不是很清晰，后面研究</li>
<li>第12行，尝试从队列中超时获取请求，如果没有取到，就先进行<code>flush</code>操作，再阻塞式获取</li>
<li>第19行，如果取出的请求是<code>REQUEST_OF_DEATH</code>，跳出循环，线程结束</li>
<li>第27行，如果请求没有限流超时标记，并且事务日志记录成功，就开始判断是否需要进行快照</li>
<li>第33行，先尝试获取一个快照锁，获取成功后单独创建一个新的线程来负责快照</li>
<li>第49行，如果取出的请求被标记为限流超时、或者请求是一个读请求，并且<code>toFlush</code>队列为空，就直接交给下一个处理器处理</li>
<li>第61行，将请求添加到<code>toFlush</code>队列</li>
<li>第62行，判断是否需要进行<code>flush</code>操作</li>
</ul>
<blockquote>
<p>记录事务日志的时候，调用的是<code>ZKDatabase.append(Request)</code>方法，这个方法的会记录事务日志，并且会用一个变量<code>txnCount</code>记录事务的数量，但是查源码会发现，<code>ZKDatabase.append(Request)</code>只有在请求是事务请求时才会记录，返回成功，否则返回失败，但<code>txnCount</code>却没有判断请求是否为事务请求，也就是说不论请求是事务的还是非事务的<code>txnCount</code>都会记录。我看了这个段代码之后，觉得可能有问题，已经提了issue，<a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper/pull/1744">https://github.com/apache/zookeeper/pull/1744</a></p>
</blockquote>
<h4 id="FinalRequestProcessor"><a href="#FinalRequestProcessor" class="headerlink" title="FinalRequestProcessor"></a>FinalRequestProcessor</h4><p>javadoc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This Request processor actually applies any transaction associated with a request and services any queries. <span class="function">It is always at the end of a RequestProcessor <span class="title">chain</span> <span class="params">(hence the name)</span>, so it does not have a nextProcessor member. This RequestProcessor counts on ZooKeeperServer to populate the outstandingRequests member of ZooKeeperServer.</span></span><br></pre></td></tr></table></figure>
<p>从文档介绍，可以得出，<code>FinalRequestProcessor</code>的作用和特点:</p>
<ul>
<li>是将事务请求应用到数据库的处理器</li>
<li>是实际执行查询的处理器</li>
<li>位于处理器链的最后一个，没有<code>nextProcessor</code></li>
<li>最后一句没看懂，依赖ZooKeeperServer来传递未完成的请求？？</li>
</ul>
<p>代码太多就不贴了，正如文档所说，<code>FinalRequestProcessor</code>所做的事情如下:</p>
<ul>
<li><code>applyRequest</code>,将请求交给<code>zkServer</code>处理，包含事务请求和查询请求，记录处理的返回结果</li>
<li>将<code>zkServer</code>中正在处理的请求减1</li>
<li>构建响应体、响应头</li>
<li>响应交给<code>ServerCnxn</code>处理</li>
</ul>
<p><code>RequestProcessor</code>就说到这里，下面看一下<code>ZooKeeperServer</code>中另一个比较重要的类</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#ZooKeeper" >
    <span class="tag-code">ZooKeeper</span>
  </a>

  <a href="/tags#源码阅读" >
    <span class="tag-code">源码阅读</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/08/29/zk-code002/">
        <span class="nav-arrow">← </span>
        
          ZooKeeper源码阅读——ServerCnxnFactory
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo="lanicc/lanicc.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-nav-text">恢复数据</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-nav-text">加载数据库</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-1-deserialize-%E5%BF%AB%E7%85%A7%E6%81%A2%E5%A4%8D"><span class="toc-nav-text">1.1.1 deserialize 快照恢复</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-3-1-fastForwardFromEdits-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D"><span class="toc-nav-text">1.1.3.1 fastForwardFromEdits 事务日志恢复</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%90%AF%E5%8A%A8zkServer"><span class="toc-nav-text">启动zkServer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-nav-text">请求处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-nav-text">连接请求处理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%85%B6%E4%BB%96%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-nav-text">其他请求处理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RequestThrottler-%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81%E5%99%A8"><span class="toc-nav-text">RequestThrottler 请求限流器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-nav-text">配置项</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">具体实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RequestProcessor-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-nav-text">RequestProcessor 请求处理器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#PrepRequestProcessor"><span class="toc-nav-text">PrepRequestProcessor</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#SyncRequestProcessor"><span class="toc-nav-text">SyncRequestProcessor</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#FinalRequestProcessor"><span class="toc-nav-text">FinalRequestProcessor</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://lanicc.github.io/2021/08/29/zk-code003/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>